{"version":3,"sources":["gl/resize.js","gl/keydown.js","config.js","gl/map/map-chunk.js","gl/map/map-chunk-renderer.js","util/stats-wrapper.js","util/compatability.js","gl/map/tile-materials-manager.js","gl/map/sparse-object-manager.js","gl/map/object-materials-manager.js","gl/map/map-object.js","gl/map/map-light-overlay.js","gl/renderer.js","gl/main.js","components/Display/index.js","App.js","serviceWorker.js","index.js"],"names":["_queue","_names","_lastWidth","window","innerWidth","_lastHeight","innerHeight","_running","addEventListener","requestAnimationFrame","len","length","i","_ref","key","TILE_PIXEL_LENGTH","TILES_PER_CHUNK","CHUNK_TILE_LENGTH","CHUNK_PIXEL_LENGTH","MAP_TILES_WIDE","MAP_CHUNKS_WIDE","MAP_TILES_HIGH","MAP_CHUNKS_HIGH","MAP_PIXELS_HIGH","HALF_CHUNK_PIXEL_LENGTH","HALF_TILE_PIXEL_LENGTH","console","debug","assert","Chunk","Object","classCallCheck","this","_sprites","Array","_scene","THREE","_target","RENDER_TARGET_OPTIONS","_material","objectSpread","map","texture","MATERIAL_OPTIONS","_mesh","GEOMETRY","_currentSceneLocation","x","y","_currentMapLocation","_targetMapLocation","_dirty","generateMipmaps","position","z","_fill","sprites","idx","sprite","center","set","scale","add","materials","_this$_targetMapLocat","mapIdx","tileStartY","tileStartX","spritesIdx","material","renderer","camera","setRenderTarget","render","sceneHeight","CHUNK_DEBUG_SPACING","dispose","blending","side","magFilter","minFilter","format","depthBuffer","stencilBuffer","ChunkRenderer","_camera","_chunks","_chunksWide","_chunksHigh","_topLeftChunkCoordinate","top","left","_materialArray","_map","_sceneDimensions","width","height","updateProjectionMatrix","getMaterialArray","chunksWide","chunks","chunkCount","Math","floor","update","setSceneLocation","parentScene","ceil","PRE_RENDER_CHUNKS","chunksHigh","oldChunkCount","newChunkCount","difference","abs","splice","forEach","chunk","remove","getMesh","log","newChunk","push","_this$_topLeftChunkCo","setLeftTop","total","timer","concat","time","setChunkCoordinates","reorientChunks","timeEnd","newTop","max","start","temp","boundary","min","bottom","newLeft","right","timeStamp","performance","now","updateCount","end","stats","Stats","OFFSCREEN_CANVAS","hasOwnProperty","WEBGL","canvas","document","createElement","getContext","e","WEBGL2","WebGL2RenderingContext","TileMaterialManager","MAX_TEXTURE_COUNT","_currentArrayPosition","_materialSet","Set","createClass","value","r","g","b","OffscreenCanvas","ctx","alpha","fillStyle","fillRect","newCanvasTexture","lightness","newTileForColor","size","SparseObjectManager","_array","_set","_group","mapObject","mesh","delete","worldMapArrayIndex","undefined","chunkRenderer","xOffset","sceneDimensions","yOffset","newValue","obj","_this","ObjectMaterialManager","newMaterial","has","options","mat","OPTIONS","addMaterial","MapObject","_worldPosition","SINGLE_TILE_GEOMETRY","newTexture","geometry","MapLighting","_geom","shininess","flatShading","specular","reflectivity","_ambientLight","_sceneObject","receiveShadow","castShadow","_light","shadow","mapSize","_cube","_generateWall","transparent","blendEquation","blendSrc","blendDst","resize","block","color","cube","offset","intensity","rWidth","rHeight","shadowMap","enabled","antialias","Renderer","_index","_rendererCount","_rendering","_cameraDelta","_tileMaterials","Int16Array","_chunkRenderer","_renderer","_context","_canvas","_cameraWorldTile","_panBoundary","_offMapBoundary","_distanceAllowedToPanOffMap","_tileHighlighter","_tileSelector","_allowMapDragWithMouse","_mouseDownLocation","_backgroundColor","_cameraTween","_objectMaterials","_objects","_lighting","_showLighting","_mouseMoveHandler","offsetX","offsetY","stopCurrentCameraTween","_this$windowOffsetToS","windowOffsetToSceneCoordinate","sceneX","sceneY","lightPos","_this$worldTileForSce","worldTileForSceneCoordinate","setWorldPosition","_mouseDownHandler","_ref2","_mouseUpHandler","_clickHandler","_ref3","_this$windowOffsetToS2","_this$worldTileForSce2","_doubleClickHandler","_ref4","_this$windowOffsetToS3","tileCenterY","to","tweenCameraToSceneCoordinate","windowWidth","windowHeight","setSize","near","far","offsetForChunkRenderer","_this$_chunkRenderer$","keydown","cy","cx","KEY_JUMP_SIZE","sceneObject","offsetAmbientLightIntensity","toggleRendering","setAnimationLoop","begin","TWEEN","_applyCameraDelta","getWebGLContextFromCanvas","context","RENDERER_OPTIONS","background","setPixelRatio","devicePixelRatio","type","group","_initTileMaterials","_initSparseObjects","greenTile","hMat","opacity","random","stop","_this2","coords","last","Tween","easing","Easing","Quadratic","Out","onUpdate","removeEventListener","chunkY","chunkX","materialCount","name","stopListeningForResize","stopListeningForKeydown","stopListeningForMouseEvents","sceneChunksWide","sceneChunksHigh","_this$sceneCoordinate","sceneCoordinateForWorldTile","round","stopRendering","startRendering","warn","callback","listenForKeydown","listenForMouseEvents","midX","midY","centerCameraOnTile","dX","dY","_this$_camera$positio","delta","panUp","panDown","panRight","panLeft","stencil","Display","props","possibleConstructorReturn","getPrototypeOf","call","ref","React","createRef","current","generateMap","destroy","react_default","a","id","className","Component","styled","_templateObject","ErrorDisplay","App","RUN","showPanel","body","append","dom","components_Display","error","Boolean","location","hostname","match","ReactDOM","src_App","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.d68fc4bd.chunk.js","sourcesContent":["/**\n * @type {function(number, number)[]}\n * @private\n */\nconst _queue = [];\n\n/**\n * @type {Object<string, number>}\n * @private\n */\nconst _names = {};\n\n/**\n * @type {number}\n * @private\n */\nlet _lastWidth = window.innerWidth;\n\n/**\n * @type {number}\n * @private\n */\nlet _lastHeight = window.innerHeight;\n\n/**\n * @type {boolean}\n * @private\n */\nlet _running = false;\n\nfunction nativeResizeCallback() {\n  if (!_running) {\n    _running = true;\n    requestAnimationFrame(() => {\n      _lastWidth = window.innerWidth;\n      _lastHeight = window.innerHeight;\n      const len = _queue.length;\n      for (let i = 0; i < len; i++) {\n        _queue[i](_lastWidth, _lastHeight);\n      }\n      _running = false;\n    });\n  }\n}\n\nwindow.addEventListener(\"resize\", nativeResizeCallback);\n\n/**\n *\n * @param name {string}\n * @param callback {function(number, number)}\n * @return {{width: number, height: number}}\n */\nexport function listenForResize(name, callback) {\n  _queue.push(callback);\n  _names[name] = _queue.length - 1;\n  console.log(\"Started listening: \" + name);\n  callback(_lastWidth, _lastHeight);\n  return { width: _lastWidth, height: _lastHeight };\n}\n\n/**\n *\n * @param name {string}\n */\nexport function stopListeningForResize(name) {\n  const idx = _names[name];\n  console.assert(idx, \"No such listener: \" + name);\n  _queue.splice(idx, 1);\n  delete _names[name];\n  console.log(\"Stopped listening for \" + name);\n}\n","/**\n * @type {function(string)[]}\n * @private\n */\nconst _queue = [];\n\n/**\n * @type {Object<string, number>}\n * @private\n */\nconst _names = {};\n\nfunction nativeKeydownCallback({ key }) {\n  const len = _queue.length;\n  for (let i = 0; i < len; i++) {\n    _queue[i](key);\n  }\n}\n\nwindow.addEventListener(\"keydown\", nativeKeydownCallback);\n\n/**\n *\n * @param name {string}\n * @param callback {function(string)}\n */\nexport function listenForKeydown(name, callback) {\n  _queue.push(callback);\n  _names[name] = _queue.length - 1;\n  console.log(\"Started listening: \" + name);\n}\n\n/**\n *\n * @param name {string}\n */\nexport function stopListeningForKeydown(name) {\n  const idx = _names[name];\n  console.assert(idx, \"No such listener: \" + name);\n  _queue.splice(idx, 1);\n  delete _names[name];\n  console.log(\"Stopped listening for \" + name);\n}\n","// Existential\nexport const TILE_PIXEL_LENGTH = 32;\n\n// Map size\nexport const MAP_CHUNKS_WIDE = 32;\nexport const MAP_CHUNKS_HIGH = 32;\n\n// Performance\n/**\n * The length of a side of a chunk, in tiles. Larger means more work less often,\n * and fewer means less work more often when panning.\n *\n * @type {number}\n */\nexport const CHUNK_TILE_LENGTH = 16;\n\n/**\n * How many chunks outside of the visible area to render. The idea is that you\n * do more work when panning in order to be able to pan more without having to\n * recalculate chunks.\n *\n * @type {number}\n */\nexport const PRE_RENDER_CHUNKS = 1;\n\n// Computed\nexport const TILES_PER_CHUNK = CHUNK_TILE_LENGTH * CHUNK_TILE_LENGTH;\nexport const CHUNK_PIXEL_LENGTH = TILE_PIXEL_LENGTH * CHUNK_TILE_LENGTH;\nexport const MAP_TILES_WIDE = MAP_CHUNKS_WIDE * CHUNK_TILE_LENGTH;\nexport const MAP_TILES_HIGH = MAP_CHUNKS_HIGH * CHUNK_TILE_LENGTH;\nexport const MAP_PIXELS_HIGH = MAP_TILES_HIGH * TILE_PIXEL_LENGTH;\nexport const MAP_PIXELS_WIDE = MAP_TILES_WIDE * TILE_PIXEL_LENGTH;\nexport const HALF_CHUNK_PIXEL_LENGTH = CHUNK_PIXEL_LENGTH >> 1;\nexport const HALF_TILE_PIXEL_LENGTH = TILE_PIXEL_LENGTH >> 1;\n\nconsole.debug(\"MAP_TILES_WIDE\", MAP_TILES_WIDE);\nconsole.debug(\"CHUNK_PIXEL_LENGTH\", CHUNK_PIXEL_LENGTH);\nconsole.assert(TILE_PIXEL_LENGTH % 8 === 0, \"You're gonna have a bad time.\");\n","import * as THREE from \"three\";\nimport {\n  CHUNK_PIXEL_LENGTH,\n  CHUNK_TILE_LENGTH,\n  HALF_CHUNK_PIXEL_LENGTH,\n  MAP_TILES_WIDE,\n  TILE_PIXEL_LENGTH,\n  TILES_PER_CHUNK\n} from \"../../config\";\n\n/**\n * A map chunk is a N x N square of tiles that is rendered into a texture that\n * is added to the scene. The idea is that instead of rendering N x Tile Count,\n * you can just render Chunk Count every frame resulting in far less overhead\n * and less updating of vertex data.\n */\nexport default class Chunk {\n  static CHUNK_DEBUG_SPACING = 0;\n\n  static MATERIAL_OPTIONS = {\n    blending: THREE.NoBlending,\n    side: THREE.FrontSide\n  };\n\n  static RENDER_TARGET_OPTIONS = {\n    magFilter: THREE.NearestFilter,\n    minFilter: THREE.NearestFilter,\n    format: THREE.RGBFormat,\n    depthBuffer: false,\n    stencilBuffer: false\n  };\n\n  /**\n   *\n   * @type {PlaneBufferGeometry}\n   */\n  static GEOMETRY = new THREE.PlaneBufferGeometry(\n    CHUNK_PIXEL_LENGTH,\n    CHUNK_PIXEL_LENGTH\n  );\n\n  /**\n   *\n   * @type {Sprite[]}\n   * @private\n   */\n  _sprites = new Array(TILES_PER_CHUNK);\n\n  /**\n   *\n   * @type {Scene}\n   * @private\n   */\n  _scene = new THREE.Scene();\n\n  /**\n   *\n   * @type {WebGLRenderTarget}\n   * @private\n   */\n  _target = new THREE.WebGLRenderTarget(\n    CHUNK_PIXEL_LENGTH,\n    CHUNK_PIXEL_LENGTH,\n    Chunk.RENDER_TARGET_OPTIONS\n  );\n\n  /**\n   *\n   * @type {MeshBasicMaterial}\n   * @private\n   */\n  _material = new THREE.MeshBasicMaterial({\n    map: this._target.texture,\n    ...Chunk.MATERIAL_OPTIONS\n  });\n\n  /**\n   *\n   * @type {Mesh}\n   * @private\n   */\n  _mesh = new THREE.Mesh(Chunk.GEOMETRY, this._material);\n\n  /**\n   *\n   * @type {{x: number, y: number}}\n   * @private\n   */\n  _currentSceneLocation = { x: -1, y: -1 };\n\n  /**\n   *\n   * @type {{x: number, y: number}}\n   * @private\n   */\n  _currentMapLocation = { x: -1, y: -1 };\n\n  /**\n   *\n   * @type {{x: number, y: number}}\n   * @private\n   */\n  _targetMapLocation = { x: -1, y: -1 };\n\n  /**\n   *\n   * @type {boolean}\n   * @private\n   */\n  _dirty = false;\n\n  constructor() {\n    this._target.texture.generateMipmaps = false;\n    this._mesh.position.z = 0;\n    this._fill();\n  }\n\n  _fill() {\n    const sprites = this._sprites;\n    let idx = 0;\n    for (let y = 0; y < CHUNK_TILE_LENGTH; y++) {\n      for (let x = 0; x < CHUNK_TILE_LENGTH; x++) {\n        const sprite = new THREE.Sprite();\n        sprite.center.set(0, 0);\n        sprite.scale.set(TILE_PIXEL_LENGTH, TILE_PIXEL_LENGTH, 1);\n        sprite.position.set(x * TILE_PIXEL_LENGTH, y * TILE_PIXEL_LENGTH, 1);\n        this._scene.add(sprite);\n        sprites[idx++] = sprite;\n      }\n    }\n  }\n\n  /**\n   *\n   * @param map {Int16Array}\n   * @param materials {SpriteMaterial[]}\n   * @return {Chunk}\n   */\n  update(map, materials) {\n    const { x, y } = this._targetMapLocation;\n\n    if (this._currentMapLocation.x === x && this._currentMapLocation.y === y) {\n      return this;\n    }\n\n    const tileStartY = x * (MAP_TILES_WIDE * CHUNK_TILE_LENGTH);\n    const tileStartX = y * CHUNK_TILE_LENGTH;\n    const sprites = this._sprites;\n\n    let mapIdx;\n    let spritesIdx = 0;\n    for (let y = 0; y < CHUNK_TILE_LENGTH; y++) {\n      mapIdx = tileStartY + tileStartX + y * MAP_TILES_WIDE;\n      for (let x = 0; x < CHUNK_TILE_LENGTH; x++) {\n        const sprite = sprites[spritesIdx++];\n        const material = materials[map[mapIdx++]];\n        if (sprite.material !== material) {\n          sprite.material = material;\n          this._dirty = true;\n        }\n      }\n    }\n\n    this._currentMapLocation.x = x;\n    this._currentMapLocation.y = y;\n\n    return this;\n  }\n\n  /**\n   *\n   * @param x {number}\n   * @param y {number}\n   * @return {Chunk}\n   */\n  setChunkCoordinates(x, y) {\n    this._targetMapLocation.x = x;\n    this._targetMapLocation.y = y;\n    return this;\n  }\n\n  /**\n   *\n   * @param renderer {WebGLRenderer}\n   * @param camera {OrthographicCamera}\n   * @returns {boolean}\n   */\n  render(renderer, camera) {\n    if (!this._dirty) {\n      return false;\n    }\n\n    renderer.setRenderTarget(this._target);\n    renderer.render(this._scene, camera);\n    this._dirty = false;\n    return true;\n  }\n\n  /**\n   *\n   * @return {Mesh}\n   */\n  getMesh() {\n    return this._mesh;\n  }\n\n  /**\n   *\n   * @param x {number}\n   * @param y {number}\n   * @param sceneHeight {number}\n   * @returns {Chunk}\n   */\n  setSceneLocation(x, y, sceneHeight) {\n    if (this._currentSceneLocation.x !== x) {\n      this._currentSceneLocation.x = x;\n      this._mesh.position.x =\n        x * (CHUNK_PIXEL_LENGTH + Chunk.CHUNK_DEBUG_SPACING) +\n        HALF_CHUNK_PIXEL_LENGTH;\n    }\n\n    if (this._currentSceneLocation.y !== y) {\n      this._currentSceneLocation.y = y;\n      this._mesh.position.y =\n        sceneHeight +\n        HALF_CHUNK_PIXEL_LENGTH -\n        (y + 1) * (CHUNK_PIXEL_LENGTH + Chunk.CHUNK_DEBUG_SPACING);\n    }\n\n    return this;\n  }\n\n  dispose() {\n    this._target.dispose();\n    this._material.dispose();\n    this._target = null;\n    this._material = null;\n    this._mesh = null;\n    this._scene = null;\n\n    // Note that we do not own the tile materials, so do NOT dispose of them.\n    this._sprites = null;\n  }\n}\n","import Chunk from \"./map-chunk\";\nimport * as THREE from \"three\";\nimport {\n  CHUNK_PIXEL_LENGTH,\n  MAP_CHUNKS_HIGH,\n  MAP_CHUNKS_WIDE,\n  PRE_RENDER_CHUNKS\n} from \"../../config\";\n\nexport default class ChunkRenderer {\n  /**\n   *\n   * @type {OrthographicCamera}\n   * @private\n   */\n  _camera = new THREE.OrthographicCamera(\n    0,\n    CHUNK_PIXEL_LENGTH,\n    CHUNK_PIXEL_LENGTH,\n    0,\n    -1,\n    2000\n  );\n\n  /**\n   *\n   * @type {Chunk[]}\n   * @private\n   */\n  _chunks = [];\n\n  /**\n   *\n   * @type {number}\n   * @private\n   */\n  _chunksWide = 0;\n\n  /**\n   *\n   * @type {number}\n   * @private\n   */\n  _chunksHigh = 0;\n\n  /**\n   *\n   * @type {{top: number, left: number}}\n   * @private\n   */\n  _topLeftChunkCoordinate = { top: -1, left: -1 };\n\n  /**\n   *\n   * @type {SpriteMaterial[]}\n   * @private\n   */\n  _materialArray = null;\n\n  /**\n   *\n   * @type {Int16Array}\n   * @private\n   */\n  _map = null;\n\n  /**\n   *\n   * @type {{width: number, height: number}}\n   * @private\n   */\n  _sceneDimensions = { width: 0, height: 0 };\n\n  /**\n   *\n   * @param map {Int16Array}\n   * @param materials {TileMaterialManager}\n   */\n  constructor(map, materials) {\n    this._camera.position.z = 1;\n    this._camera.position.x = 0;\n    this._camera.position.y = 0;\n    this._camera.updateProjectionMatrix();\n    this._materialArray = materials.getMaterialArray();\n    this._map = map;\n  }\n\n  reorientChunks() {\n    const chunksWide = this.chunksWide();\n    const chunks = this._chunks;\n    const chunkCount = chunks.length;\n    const sceneHeight = this._sceneDimensions.height;\n    const materials = this._materialArray;\n    const map = this._map;\n    for (let i = 0; i < chunkCount; i++) {\n      const x = i % chunksWide;\n      const y = Math.floor(i / chunksWide);\n      chunks[i].update(map, materials).setSceneLocation(x, y, sceneHeight);\n    }\n  }\n\n  /**\n   *\n   * @param width {number}\n   * @param height {number}\n   * @param parentScene {Scene}\n   */\n  resize(width, height, parentScene) {\n    // Calculate the width and height of the scene in chunks. The pre-render\n    // chunk value is how many chunks past the actual window border we should\n    // calculate ON EACH SIDE, hence the magic number `* 2`.\n    const chunksWide =\n      Math.ceil(width / CHUNK_PIXEL_LENGTH) + PRE_RENDER_CHUNKS * 2;\n    const chunksHigh =\n      Math.ceil(height / CHUNK_PIXEL_LENGTH) + PRE_RENDER_CHUNKS * 2;\n\n    const oldChunkCount = this._chunks.length;\n    const newChunkCount = chunksWide * chunksHigh;\n\n    // Save dimension info.\n    this._chunksHigh = chunksHigh;\n    this._chunksWide = chunksWide;\n    this._sceneDimensions.width = chunksWide * CHUNK_PIXEL_LENGTH;\n    this._sceneDimensions.height = chunksHigh * CHUNK_PIXEL_LENGTH;\n\n    if (oldChunkCount !== newChunkCount) {\n      const difference = Math.abs(oldChunkCount - newChunkCount);\n\n      // Are we destroying chunks?\n      if (oldChunkCount > newChunkCount) {\n        // If so clean up\n        this._chunks.splice(newChunkCount, difference).forEach(chunk => {\n          // Chunks don't know about their parent so this is our responsibility\n          parentScene.remove(chunk.getMesh());\n\n          // Call dispose on the chunk\n          chunk.dispose();\n        });\n\n        console.log(\"Destroyed\", difference, \"chunks (\", newChunkCount, \")\");\n      } else {\n        // In this case we're adding chunks\n        for (let i = oldChunkCount; i < newChunkCount; i++) {\n          // Create a new one and add it to the scene and our list.\n          const newChunk = new Chunk();\n          this._chunks.push(newChunk);\n          parentScene.add(newChunk.getMesh());\n        }\n\n        console.log(\n          \"Created\",\n          difference,\n          \"chunks (\",\n          chunksWide,\n          \"x\",\n          chunksHigh,\n          \", total:\",\n          newChunkCount,\n          \")\"\n        );\n      }\n    }\n\n    // No matter what we want to update all chunks because they could be in any\n    // order. There is, theoretically, an optimization here to only update the\n    // chunks that have moved out of order because it isn't the case that they\n    // have all changed location, depending on how the size has changed.\n    const { left, top } = this._topLeftChunkCoordinate;\n    this.setLeftTop(left, top);\n  }\n\n  /**\n   *\n   * @param left {number} the X index of the start chunk\n   * @param top {number} the Y index of the start chunk\n   */\n  setLeftTop(left, top) {\n    const chunksWide = this.chunksWide();\n    const chunksHigh = this.chunksHigh();\n    const total = chunksWide * chunksHigh;\n    const timer = `setLeftTop(${left}, ${top}) : ${total}`;\n    console.time(timer);\n\n    let idx = 0;\n    for (let y = top; y < top + chunksHigh; y++) {\n      for (let x = left; x < left + chunksWide; x++) {\n        this._chunks[idx++].setChunkCoordinates(x, y);\n      }\n    }\n\n    this._topLeftChunkCoordinate.left = left;\n    this._topLeftChunkCoordinate.top = top;\n    this.reorientChunks();\n\n    console.timeEnd(timer);\n  }\n\n  /**\n   * Pan the map up by one chunk and mark those chunks as having new\n   * coordinates. This does not do the work to redraw them: you must call\n   * ChunkRenderer#reorientChunks() for that.\n   *\n   * @returns {boolean} True if the pan happened\n   */\n  panUp() {\n    const newTop = Math.max(0, this._topLeftChunkCoordinate.top - 1);\n\n    if (newTop === this._topLeftChunkCoordinate.top) {\n      return false;\n    }\n\n    const chunksWide = this.chunksWide();\n    const chunksHigh = this.chunksHigh();\n    const left = this._topLeftChunkCoordinate.left;\n\n    const start = chunksWide * (chunksHigh - 1);\n\n    // select the last row\n    const temp = this._chunks.splice(start, chunksWide);\n    for (let x = 0; x < chunksWide; x++) {\n      temp[x].setChunkCoordinates(left + x, newTop);\n    }\n\n    this._chunks = temp.concat(this._chunks);\n    this._topLeftChunkCoordinate.top = newTop;\n\n    return true;\n  }\n\n  /**\n   * Pan the map down by one chunk and mark those chunks as having new\n   * coordinates. This does not do the work to redraw them: you must call\n   * ChunkRenderer#reorientChunks() for that.\n   *\n   * @returns {boolean} True if the pan happened\n   */\n  panDown() {\n    const boundary = MAP_CHUNKS_HIGH - this.chunksHigh();\n    const newTop = Math.min(boundary, this._topLeftChunkCoordinate.top + 1);\n\n    if (newTop === this._topLeftChunkCoordinate.top) {\n      return false;\n    }\n\n    const chunksWide = this.chunksWide();\n    const left = this._topLeftChunkCoordinate.left;\n\n    // Select the first row\n    const temp = this._chunks.splice(0, chunksWide);\n    const bottom = newTop + this.chunksHigh() - 1;\n    for (let x = 0; x < chunksWide; x++) {\n      temp[x].setChunkCoordinates(left + x, bottom);\n    }\n\n    this._chunks = this._chunks.concat(temp);\n    this._topLeftChunkCoordinate.top = newTop;\n\n    return true;\n  }\n\n  /**\n   * Pan the map right by one chunk and mark those chunks as having new\n   * coordinates. This does not do the work to redraw them: you must call\n   * ChunkRenderer#reorientChunks() for that.\n   *\n   * @returns {boolean} True if the pan happened\n   */\n  panRight() {\n    const chunksWide = this.chunksWide();\n    const newLeft = Math.min(\n      MAP_CHUNKS_WIDE - chunksWide,\n      this._topLeftChunkCoordinate.left + 1\n    );\n\n    if (newLeft === this._topLeftChunkCoordinate.left) {\n      return false;\n    }\n\n    const chunksHigh = this.chunksHigh();\n    const top = this._topLeftChunkCoordinate.top;\n    const chunks = this._chunks;\n    const right = newLeft + chunksWide - 1;\n\n    for (let y = 0; y < chunksHigh; y++) {\n      const idx = y * chunksWide;\n      const temp = chunks[idx].setChunkCoordinates(right, top + y);\n\n      chunks.splice(idx, 1);\n      chunks.splice(idx + (chunksWide - 1), 0, temp);\n    }\n\n    this._topLeftChunkCoordinate.left = newLeft;\n\n    return true;\n  }\n\n  /**\n   * Pan the map left by one chunk and mark those chunks as having new\n   * coordinates. This does not do the work to redraw them: you must call\n   * ChunkRenderer#reorientChunks() for that.\n   *\n   * @returns {boolean} True if the pan happened\n   */\n  panLeft() {\n    const newLeft = Math.max(0, this._topLeftChunkCoordinate.left - 1);\n\n    if (newLeft === this._topLeftChunkCoordinate.left) {\n      return false;\n    }\n\n    const chunksWide = this.chunksWide();\n    const chunksHigh = this.chunksHigh();\n    const top = this._topLeftChunkCoordinate.top;\n\n    const chunks = this._chunks;\n\n    for (let y = 0; y < chunksHigh; y++) {\n      const idx = y * chunksWide + (chunksWide - 1);\n      const temp = chunks[idx].setChunkCoordinates(newLeft, top + y);\n\n      chunks.splice(idx, 1);\n      chunks.splice(y * chunksWide, 0, temp);\n    }\n\n    this._topLeftChunkCoordinate.left = newLeft;\n\n    return true;\n  }\n\n  /**\n   *\n   * @param renderer {WebGLRenderer}\n   */\n  update(renderer) {\n    console.timeStamp(\"ChunkRenderer#update\");\n    const start = performance.now();\n    const chunks = this._chunks;\n    const chunkCount = chunks.length;\n    const camera = this._camera;\n    let updateCount = 0;\n    for (let i = 0; i < chunkCount; i++) {\n      if (chunks[i].render(renderer, camera)) {\n        updateCount++;\n      }\n    }\n\n    if (updateCount) {\n      const end = performance.now();\n      console.debug(\"Updated\", updateCount, \"chunks in\", end - start, \"ms\");\n    }\n  }\n\n  dispose() {\n    this._chunks.forEach(chunk => chunk.dispose());\n    this._chunks = null;\n  }\n\n  chunksWide() {\n    return this._chunksWide;\n  }\n\n  chunksHigh() {\n    return this._chunksHigh;\n  }\n\n  sceneDimensions() {\n    return this._sceneDimensions;\n  }\n\n  top() {\n    return this._topLeftChunkCoordinate.top;\n  }\n\n  left() {\n    return this._topLeftChunkCoordinate.left;\n  }\n}\n","import Stats from \"stats-js\";\n\n/**\n * @type {{begin: function(): void, end: function(): void, showPanel:\n *   function(number): void, dom: HTMLElement}}\n */\nexport const stats = new Stats();\n\nexport function show() {\n  stats.showPanel(0);\n  document.body.append(stats.dom);\n}\n","const OFFSCREEN_CANVAS = window.hasOwnProperty(\"OffscreenCanvas\");\n\nconst WEBGL = (() => {\n  try {\n    const canvas = document.createElement(\"canvas\");\n    return !!(\n      canvas.getContext(\"webgl\") || canvas.getContext(\"experimental-webgl\")\n    );\n  } catch (e) {\n    return false;\n  }\n})();\n\nconst WEBGL2 = (() => {\n  try {\n    const canvas = document.createElement(\"canvas\");\n    // noinspection JSUnresolvedVariable\n    return !!(window.WebGL2RenderingContext && canvas.getContext(\"webgl2\"));\n  } catch (e) {\n    return false;\n  }\n})();\n\nexport function warn() {\n  if (!OFFSCREEN_CANVAS) {\n    console.warn(\"OffscreenCanvas() not found!\");\n  }\n\n  if (!WEBGL2) {\n    console.warn(\"WebGL 2.0 not supported!\");\n  }\n}\n\n/**\n *\n * @return {boolean}\n */\nexport function canRun() {\n  if (!WEBGL) {\n    console.error(\"WebGL not supported.\");\n    return false;\n  }\n\n  return true;\n}\n\n/**\n *\n * @param width {number}\n * @param height {number}\n * @return {HTMLCanvasElement}\n */\nexport function newOffscreenCanvas(width, height) {\n  if (OFFSCREEN_CANVAS) {\n    // noinspection JSUnresolvedFunction\n    return new OffscreenCanvas(width, height);\n  } else {\n    // noinspection JSValidateTypes\n    return document.createElement(\"canvas\");\n  }\n}\n\n/**\n *\n * @param canvas {HTMLCanvasElement}\n * @return {WebGLRenderingContext}\n */\nexport function getWebGLContextFromCanvas(canvas) {\n  return canvas.getContext(WEBGL2 ? \"webgl2\" : \"webgl\");\n}\n","import * as THREE from \"three/src/Three\";\nimport { TILE_PIXEL_LENGTH } from \"../../config\";\nimport { newOffscreenCanvas } from \"../../util/compatability\";\n\nexport class TileMaterialManager {\n  static MAX_TEXTURE_COUNT = 16384;\n\n  /**\n   *\n   * @type {SpriteMaterial[]}\n   * @private\n   */\n  _material = new Array(TileMaterialManager.MAX_TEXTURE_COUNT);\n\n  _currentArrayPosition = 0;\n\n  /**\n   *\n   * @type {Set<SpriteMaterial>}\n   * @private\n   */\n  _materialSet = new Set();\n\n  /**\n   *\n   * @param canvas {HTMLCanvasElement}\n   * @private\n   */\n  newCanvasTexture(canvas) {\n    const map = new THREE.CanvasTexture(\n      canvas,\n      THREE.UVMapping,\n      THREE.ClampToEdgeWrapping,\n      THREE.ClampToEdgeWrapping,\n      THREE.NearestFilter,\n      THREE.NearestFilter,\n      THREE.RGBFormat,\n      THREE.UnsignedByteType,\n      1\n    );\n\n    map.generateMipmaps = false;\n\n    const material = new THREE.SpriteMaterial({ map });\n\n    this._material[this._currentArrayPosition++] = material;\n    this._materialSet.add(material);\n\n    return material;\n  }\n\n  /**\n   *\n   * @param r {number}\n   * @param g {number}\n   * @param b {number}\n   * @return {SpriteMaterial}\n   */\n  newTileForColor(r, g, b) {\n    const canvas = newOffscreenCanvas(TILE_PIXEL_LENGTH, TILE_PIXEL_LENGTH);\n    const ctx = canvas.getContext(\"2d\", { alpha: false });\n    ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;\n    ctx.fillRect(0, 0, TILE_PIXEL_LENGTH, TILE_PIXEL_LENGTH);\n    return this.newCanvasTexture(canvas);\n  }\n\n  /**\n   *\n   * @param lightness {number}\n   * @return {SpriteMaterial}\n   */\n  greenTile(lightness) {\n    return this.newTileForColor(0, 100 + Math.floor(150 * lightness), 0);\n  }\n\n  /**\n   *\n   * @return {SpriteMaterial[]}\n   */\n  getMaterialArray() {\n    return this._material;\n  }\n\n  /**\n   *\n   * @return {number}\n   */\n  size() {\n    return this._materialSet.size;\n  }\n\n  dispose() {\n    this._materialSet.forEach(material => material.map.dispose());\n    this._materialSet = null;\n    this._material = null;\n  }\n}\n","import {\n  CHUNK_PIXEL_LENGTH,\n  MAP_PIXELS_HIGH,\n  MAP_TILES_HIGH,\n  MAP_TILES_WIDE\n} from \"../../config\";\nimport * as THREE from \"three\";\n\nexport class SparseObjectManager {\n  /**\n   *\n   * @type {Array.<MapObject>}\n   * @private\n   */\n  _array = null;\n\n  /**\n   *\n   * @type {Set<MapObject>}\n   * @private\n   */\n  _set = new Set();\n\n  /**\n   *\n   * @type {Group}\n   * @private\n   */\n  _group = new THREE.Group();\n\n  constructor() {\n    this._array = new Array(MAP_TILES_WIDE * MAP_TILES_HIGH);\n    this._group.position.set(0, 0, 2);\n  }\n\n  /**\n   *\n   * @return {Group}\n   */\n  group() {\n    return this._group;\n  }\n\n  /**\n   *\n   * @param mapObject {MapObject}\n   */\n  add(mapObject) {\n    this._set.add(mapObject);\n    this._group.add(mapObject.mesh());\n  }\n\n  /**\n   *\n   * @param mapObject {MapObject}\n   * @return {boolean} true if the object was removed\n   */\n  remove(mapObject) {\n    if (this._set.delete(mapObject)) {\n      this._array[mapObject.worldMapArrayIndex()] = undefined;\n      this._group.remove(mapObject.mesh());\n      mapObject.dispose();\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * @param {ChunkRenderer} chunkRenderer\n   * @return {SparseObjectManager}\n   */\n  offsetForChunkRenderer(chunkRenderer) {\n    const xOffset = -chunkRenderer.left() * CHUNK_PIXEL_LENGTH;\n\n    const bottom =\n      chunkRenderer.top() * CHUNK_PIXEL_LENGTH +\n      chunkRenderer.sceneDimensions().height;\n\n    const yOffset = MAP_PIXELS_HIGH - bottom;\n\n    this._group.position.x = xOffset;\n    this._group.position.y = -yOffset;\n\n    return this;\n  }\n\n  /**\n   *\n   * @param newValue {?number}\n   * @return {SparseObjectManager|number}\n   */\n  z(newValue) {\n    if (!newValue || newValue < 2) {\n      return this._group.position.z;\n    }\n\n    if (newValue === this._group.position.z) {\n      return this;\n    }\n\n    this._set.forEach(obj => obj.z(newValue));\n    this._group.position.z = newValue;\n\n    return this;\n  }\n\n  dispose() {\n    this._set.forEach(obj => this.remove(obj));\n    this._set = null;\n    this._array = null;\n  }\n}\n","import * as THREE from \"three\";\n\nexport default class ObjectMaterialManager {\n  static MAX_TEXTURE_COUNT = 16384;\n\n  static OPTIONS = {\n    side: THREE.FrontSide\n  };\n\n  /**\n   *\n   * @type {Set<Material>}\n   * @private\n   */\n  _materialSet = new Set();\n\n  addMaterial(newMaterial) {\n    if (this._materialSet.has(newMaterial)) {\n      return this;\n    }\n\n    console.assert(\n      this._materialSet.size < ObjectMaterialManager.MAX_TEXTURE_COUNT\n    );\n\n    this._materialSet.add(newMaterial);\n\n    return this;\n  }\n\n  newMaterial(options) {\n    const mat = new THREE.MeshBasicMaterial({\n      ...options,\n      ...ObjectMaterialManager.OPTIONS\n    });\n\n    this.addMaterial(mat);\n\n    return mat;\n  }\n\n  dispose() {\n    this._materialSet.forEach(material => {\n      if (material.hasOwnProperty(\"map\") && material.map) {\n        material.map.dispose();\n      }\n    });\n    this._materialSet = null;\n  }\n}\n","import * as THREE from \"three\";\nimport {\n  HALF_TILE_PIXEL_LENGTH,\n  MAP_PIXELS_HIGH,\n  MAP_TILES_HIGH,\n  MAP_TILES_WIDE,\n  TILE_PIXEL_LENGTH\n} from \"../../config\";\n\nexport default class MapObject {\n  /**\n   *\n   * @type {PlaneBufferGeometry}\n   */\n  static SINGLE_TILE_GEOMETRY = new THREE.PlaneBufferGeometry(\n    TILE_PIXEL_LENGTH,\n    TILE_PIXEL_LENGTH\n  );\n\n  /**\n   *\n   * @type {{x: number, y: number}}\n   * @private\n   */\n  _worldPosition = { x: -1, y: -1 };\n\n  /**\n   *\n   * @type {Mesh}\n   * @private\n   */\n  _mesh = new THREE.Mesh(MapObject.SINGLE_TILE_GEOMETRY);\n\n  /**\n   *\n   * @param z {?number} The z position\n   */\n  constructor(z) {\n    this._mesh.position.z = z && z > 2 ? z : 2;\n  }\n\n  /**\n   *\n   * @param newValue {?number}\n   * @return {MapObject|number}\n   */\n  z(newValue) {\n    if (!newValue || newValue < 2) {\n      return this._mesh.position.z;\n    }\n\n    this._mesh.position.z = newValue;\n\n    return this;\n  }\n\n  /**\n   *\n   * @param newTexture {Texture}\n   * @return {MapObject|Texture}\n   */\n  texture(newTexture) {\n    if (newTexture) {\n      this.material().map = newTexture;\n      return this;\n    }\n\n    return this.material().map;\n  }\n\n  /**\n   *\n   * @param newMaterial\n   * @return {MapObject|Material}\n   */\n  material(newMaterial) {\n    if (newMaterial) {\n      this._mesh.material = newMaterial;\n      return this;\n    }\n\n    return this._mesh.material;\n  }\n\n  /**\n   *\n   * @param x {number}\n   * @param y {number}\n   * @return {MapObject}\n   */\n  setWorldPosition(x, y) {\n    console.assert(x >= 0 && x < MAP_TILES_WIDE);\n    console.assert(y >= 0 && y < MAP_TILES_HIGH);\n    this._worldPosition.x = x;\n    this._worldPosition.y = y;\n    this._mesh.position.x = x * TILE_PIXEL_LENGTH + HALF_TILE_PIXEL_LENGTH;\n    this._mesh.position.y =\n      MAP_PIXELS_HIGH - y * TILE_PIXEL_LENGTH - HALF_TILE_PIXEL_LENGTH;\n    return this;\n  }\n\n  /**\n   *\n   * @return {Mesh}\n   */\n  mesh() {\n    return this._mesh;\n  }\n\n  /**\n   * A convenience method that returns the one-dimensional array index this\n   * object would occupy if it was in an array the size of the map.\n   *\n   * @return {number}\n   */\n  worldMapArrayIndex() {\n    return this._worldPosition.y * MAP_TILES_WIDE + this._worldPosition.x;\n  }\n\n  dispose() {\n    if (this._mesh.geometry !== MapObject.SINGLE_TILE_GEOMETRY) {\n      this._mesh.geometry.dispose();\n    }\n    this._mesh = null;\n  }\n}\n","import * as THREE from \"three\";\nimport { TILE_PIXEL_LENGTH } from \"../../config\";\n\nexport default class MapLighting {\n  static RENDER_TARGET_OPTIONS = {\n    magFilter: THREE.NearestFilter,\n    stencilBuffer: false,\n    depthBuffer: false,\n    antialias: false\n  };\n\n  /**\n   *\n   * @type {PlaneBufferGeometry}\n   * @private\n   */\n  _geom = null;\n\n  /**\n   *\n   * @type {WebGLRenderTarget}\n   * @private\n   */\n  _target = null;\n\n  /**\n   *\n   * @type {Mesh}\n   * @private\n   */\n  _mesh = new THREE.Mesh(\n    new THREE.PlaneBufferGeometry(1, 1),\n    new THREE.MeshPhongMaterial({\n      shininess: 0,\n      flatShading: true,\n      specular: 0,\n      reflectivity: 0\n    })\n    //new THREE.MeshLambertMaterial({color: \"white\"})\n  );\n\n  /**\n   *\n   * @type {Scene}\n   * @private\n   */\n  _scene = new THREE.Scene();\n\n  /**\n   *\n   * @type {OrthographicCamera}\n   * @private\n   */\n  _camera = new THREE.OrthographicCamera(0, 1, 0, 1, -1, 10);\n\n  /**\n   *\n   * @type {boolean}\n   * @private\n   */\n  _dirty = false;\n\n  /**\n   *\n   * @type {AmbientLight}\n   * @private\n   */\n  _ambientLight = new THREE.AmbientLight(\"white\", 0.5);\n\n  /**\n   *\n   * @type {Mesh}\n   * @private\n   */\n  _sceneObject = new THREE.Mesh();\n\n  /**\n   *\n   * @param width\n   * @param height\n   * @return {Mesh}\n   * @private\n   */\n  static _generateWall(width, height) {\n    const block = new THREE.BoxBufferGeometry(width, height, 10);\n    const mat = new THREE.MeshBasicMaterial({ color: \"blue\" });\n    const cube = new THREE.Mesh(block, mat);\n    cube.castShadow = true;\n    cube.receiveShadow = false;\n    return cube;\n  }\n\n  constructor() {\n    this._mesh.position.set(0, 0, 0);\n    this._mesh.receiveShadow = true;\n    this._mesh.castShadow = false;\n    this._scene.add(this._mesh);\n\n    this._camera.position.set(0, 0, 5);\n\n    this._light = new THREE.PointLight(\"white\", 6, 0);\n    this._light.castShadow = true;\n    this._light.shadow.mapSize.x = 64;\n    this._light.shadow.mapSize.y = 64;\n    this._scene.add(this._light);\n    this._scene.add(this._ambientLight);\n\n    this._cube = MapLighting._generateWall(10, 1);\n    this._scene.add(this._cube);\n\n    this._sceneObject.material = new THREE.MeshBasicMaterial({\n      side: THREE.FrontSide,\n      transparent: true,\n      blending: THREE.CustomBlending,\n      blendEquation: THREE.AddEquation,\n      blendSrc: THREE.DstColorFactor,\n      blendDst: THREE.OneMinusDstAlphaFactor\n    });\n\n    this.resize(64, 64);\n  }\n\n  /**\n   *\n   * @param offset {number}\n   */\n  offsetAmbientLightIntensity(offset) {\n    this._ambientLight.intensity += offset;\n    this._dirty = true;\n  }\n\n  /**\n   * Change the size of the shadow plane\n   * @param width {number}\n   * @param height {number}\n   */\n  resize(width, height) {\n    const rWidth = Math.ceil(width / TILE_PIXEL_LENGTH);\n    const rHeight = Math.ceil(height / TILE_PIXEL_LENGTH);\n\n    if (this._target) {\n      this._target.dispose();\n    }\n\n    this._target = new THREE.WebGLRenderTarget(\n      rWidth,\n      rHeight,\n      MapLighting.RENDER_TARGET_OPTIONS\n    );\n\n    console.log(\"shadow render target:\", rWidth, rHeight);\n\n    this._target.texture.generateMipmaps = false;\n\n    this._mesh.geometry.dispose();\n    this._mesh.geometry = new THREE.PlaneBufferGeometry(rWidth, rHeight);\n    this._mesh.position.x = rWidth;\n    this._mesh.position.y = rHeight;\n\n    this._cube.position.set(rWidth - 2, rHeight - 2, 0);\n    this._light.position.set(rWidth, rHeight, 1);\n\n    this._camera.right = rWidth;\n    this._camera.top = rHeight;\n    this._camera.position.x = rWidth / 2;\n    this._camera.position.y = rHeight / 2;\n    this._camera.updateProjectionMatrix();\n\n    this._sceneObject.geometry.dispose();\n    this._sceneObject.geometry = new THREE.PlaneBufferGeometry(width, height);\n    this._sceneObject.material.map = this._target.texture;\n    this._sceneObject.position.set(width / 2, height / 2, 100);\n    this._dirty = true;\n  }\n\n  lightPos(x, y) {\n    this._light.position.set(x / TILE_PIXEL_LENGTH, y / TILE_PIXEL_LENGTH, 1);\n    this._dirty = true;\n  }\n\n  /**\n   *\n   * @param renderer {WebGLRenderer}\n   */\n  render(renderer) {\n    if (!this._dirty) {\n      return;\n    }\n\n    renderer.setRenderTarget(this._target);\n    renderer.shadowMap.enabled = true;\n    renderer.render(this._scene, this._camera);\n    renderer.shadowMap.enabled = false;\n    this._dirty = false;\n  }\n\n  dispose() {\n    this._geom.dispose();\n    this._target.dispose();\n    this._geom = null;\n    this._target = null;\n  }\n\n  sceneObject() {\n    return this._sceneObject;\n  }\n}\n","import * as THREE from \"three\";\nimport { listenForResize, stopListeningForResize } from \"./resize\";\nimport { listenForKeydown, stopListeningForKeydown } from \"./keydown\";\nimport ChunkRenderer from \"./map/map-chunk-renderer\";\nimport {\n  CHUNK_PIXEL_LENGTH,\n  CHUNK_TILE_LENGTH,\n  MAP_CHUNKS_WIDE,\n  MAP_TILES_HIGH,\n  MAP_TILES_WIDE,\n  TILE_PIXEL_LENGTH\n} from \"../config\";\nimport { stats } from \"../util/stats-wrapper\";\nimport { getWebGLContextFromCanvas } from \"../util/compatability\";\nimport { TileMaterialManager } from \"./map/tile-materials-manager\";\nimport TWEEN from \"@tweenjs/tween.js\";\nimport { SparseObjectManager } from \"./map/sparse-object-manager\";\nimport ObjectMaterialManager from \"./map/object-materials-manager\";\nimport MapObject from \"./map/map-object\";\nimport MapLighting from \"./map/map-light-overlay\";\n\nexport default class Renderer {\n  /**\n   * The total amount of renderers.\n   *\n   * @type {number}\n   * @private\n   */\n  static _rendererCount = 0;\n\n  /**\n   * The amount of pixels to jump when a panning key is hit.\n   *\n   * @type {number}\n   */\n  static KEY_JUMP_SIZE = CHUNK_PIXEL_LENGTH;\n\n  /**\n   * The WebGLRenderer options\n   *\n   * @type {Object.<String, *>}\n   */\n  static RENDERER_OPTIONS = {\n    antialias: false,\n    stencil: false\n  };\n\n  /**\n   * Our rendered scene, displayed to the player.\n   *\n   * @type {Scene}\n   * @private\n   */\n  _scene = new THREE.Scene();\n\n  /**\n   * The camera used to render this scene (initialized later.)\n   *\n   * @type {OrthographicCamera}\n   * @private\n   */\n  _camera = new THREE.OrthographicCamera(1, 1, 1, 1, 0, 1);\n\n  /**\n   * Our renderer index, among the total global renderers.\n   *\n   * @type {number}\n   * @private\n   */\n  _index = Renderer._rendererCount++;\n\n  /**\n   * Whether or not we should draw frames. Note that after this is changed from\n   * {true} to {false} you need to call startRendering()\n   *\n   * @type {boolean}\n   * @private\n   */\n  _rendering = false;\n\n  /**\n   * The amount the camera should move on the X, Y plane before next frame.\n   *\n   * @type {{x: number, y: number}}\n   * @private\n   */\n  _cameraDelta = { x: 0, y: 0 };\n\n  /**\n   *\n   * @type {TileMaterialManager}\n   * @private\n   */\n  _tileMaterials = new TileMaterialManager();\n\n  /**\n   *\n   * @type {Int16Array}\n   * @private\n   */\n  _map = new Int16Array(MAP_TILES_WIDE * MAP_TILES_HIGH);\n\n  /**\n   *\n   * @type {ChunkRenderer}\n   * @private\n   */\n  _chunkRenderer = new ChunkRenderer(this._map, this._tileMaterials);\n\n  /**\n   *\n   * @type {WebGLRenderer}\n   * @private\n   */\n  _renderer = null;\n\n  /**\n   *\n   * @type {WebGLRenderingContext}\n   * @private\n   */\n  _context = null;\n\n  /**\n   * @type {HTMLCanvasElement}\n   * @private\n   */\n  _canvas = null;\n\n  /**\n   *\n   * @type {{x: number, y: number}}\n   * @private\n   */\n  _cameraWorldTile = { x: 0, y: 0 };\n\n  /**\n   *\n   * @type {{offset: number, top: number, bottom: number, left: number, right:\n   *   number}}\n   * @private\n   */\n  _panBoundary = {\n    offset: 0,\n    top: 0,\n    left: 0,\n    right: 0,\n    bottom: 0\n  };\n\n  /**\n   *\n   * @type {{top: number, left: number, bottom: number, right: number}}\n   * @private\n   */\n  _offMapBoundary = {\n    top: 0,\n    left: 0,\n    bottom: 0,\n    right: 0\n  };\n\n  /**\n   *\n   * @type {number}\n   * @private\n   */\n  _distanceAllowedToPanOffMap = TILE_PIXEL_LENGTH * 2;\n\n  /**\n   *\n   * @type {MapObject}\n   * @private\n   */\n  _tileHighlighter = null;\n\n  /**\n   *\n   * @type {MapObject}\n   * @private\n   */\n  _tileSelector = null;\n\n  /**\n   *\n   * @type {boolean}\n   * @private\n   */\n  _allowMapDragWithMouse = true;\n\n  /**\n   *\n   * @type {?{x: number, y: number}}\n   * @private\n   */\n  _mouseDownLocation = null;\n\n  /**\n   * The background of the scene beyond the map.\n   *\n   * @type {Color}\n   * @private\n   */\n  _backgroundColor = new THREE.Color(0x51669a);\n\n  /**\n   *\n   * @type {TWEEN.Tween}\n   * @private\n   */\n  _cameraTween = null;\n\n  /**\n   *\n   * @type {ObjectMaterialManager}\n   * @private\n   */\n  _objectMaterials = new ObjectMaterialManager();\n\n  /**\n   *\n   * @type {SparseObjectManager}\n   * @private\n   */\n  _objects = new SparseObjectManager();\n\n  /**\n   *\n   * @type {MapLighting}\n   * @private\n   */\n  _lighting = new MapLighting();\n\n  /**\n   *\n   * @type {boolean}\n   * @private\n   */\n  _showLighting = true;\n\n  /**\n   * Constructs the renderer and sets initial values like the Z position of the\n   * camera that shouldn't really ever change through the life of the renderer.\n   *\n   * @param canvas {HTMLCanvasElement}\n   */\n  constructor(canvas) {\n    this._canvas = canvas;\n    this._context = getWebGLContextFromCanvas(this._canvas);\n    this._renderer = new THREE.WebGLRenderer({\n      canvas,\n      context: this._context,\n      ...Renderer.RENDERER_OPTIONS\n    });\n\n    this._scene.background = this._backgroundColor;\n    this._renderer.setPixelRatio(window.devicePixelRatio);\n    this._renderer.shadowMap.type = THREE.PCFShadowMap;\n    this._camera.position.z = 100;\n\n    // Add sparse object groups\n    this._scene.add(this._objects.group());\n    this._scene.add(this._lighting.sceneObject());\n\n    this._initTileMaterials();\n    this._initSparseObjects();\n  }\n\n  _initTileMaterials() {\n    const count = 9;\n    for (let i = 0; i < count; i += 1) {\n      this._tileMaterials.greenTile(i * 0.005);\n    }\n  }\n\n  _initSparseObjects() {\n    const hMat = this._objectMaterials.newMaterial({\n      color: 0xffff00,\n      opacity: 0.55,\n      transparent: true\n    });\n    this._tileHighlighter = new MapObject(5);\n    this._tileHighlighter.material(hMat).setWorldPosition(0, 0);\n    this._objects.add(this._tileHighlighter);\n\n    const mat = this._objectMaterials.newMaterial({\n      color: 0x0000ff,\n      opacity: 0.55,\n      transparent: true\n    });\n    this._tileSelector = new MapObject(3);\n    this._tileSelector.material(mat).setWorldPosition(0, 0);\n    this._objects.add(this._tileSelector);\n  }\n\n  addManyRandomBlueObjects() {\n    const mat = this._objectMaterials.newMaterial({\n      color: 0x0000ff,\n      opacity: 0.55,\n      transparent: true\n    });\n    for (let i = 0; i < 16000; i++) {\n      this._objects.add(\n        new MapObject(2)\n          .material(mat)\n          .setWorldPosition(\n            Math.floor(Math.random() * MAP_TILES_WIDE),\n            Math.floor(Math.random() * MAP_TILES_HIGH)\n          )\n      );\n    }\n  }\n\n  windowOffsetToSceneCoordinate(offsetX, offsetY) {\n    const sceneX = this._camera.position.x + offsetX;\n    const sceneY = this._camera.position.y + this.height() - offsetY;\n    return { sceneX, sceneY };\n  }\n\n  _mouseMoveHandler = ({ offsetX, offsetY }) => {\n    if (this._mouseDownLocation && this._allowMapDragWithMouse) {\n      this.stopCurrentCameraTween();\n      this._cameraDelta.x += this._mouseDownLocation.x - offsetX;\n      this._cameraDelta.y += offsetY - this._mouseDownLocation.y;\n      this._mouseDownLocation.x = offsetX;\n      this._mouseDownLocation.y = offsetY;\n      return;\n    }\n\n    const { sceneX, sceneY } = this.windowOffsetToSceneCoordinate(\n      offsetX,\n      offsetY\n    );\n\n    this._lighting.lightPos(sceneX + this.width(), sceneY + this.height());\n\n    const { x, y } = this.worldTileForSceneCoordinate(sceneX, sceneY);\n    // noinspection JSSuspiciousNameCombination\n    this._tileHighlighter.setWorldPosition(Math.floor(x), Math.floor(y));\n  };\n\n  _mouseDownHandler = ({ offsetX, offsetY }) => {\n    this._mouseDownLocation = { x: offsetX, y: offsetY };\n  };\n\n  _mouseUpHandler = () => {\n    this._mouseDownLocation = null;\n  };\n\n  _clickHandler = ({ offsetX, offsetY }) => {\n    const { sceneX, sceneY } = this.windowOffsetToSceneCoordinate(\n      offsetX,\n      offsetY\n    );\n    const { x, y } = this.worldTileForSceneCoordinate(sceneX, sceneY);\n    // noinspection JSSuspiciousNameCombination\n    this._tileSelector.setWorldPosition(Math.floor(x), Math.floor(y));\n  };\n\n  _doubleClickHandler = ({ offsetX, offsetY }) => {\n    const { sceneX, sceneY } = this.windowOffsetToSceneCoordinate(\n      offsetX,\n      offsetY\n    );\n\n    console.log(\n      \"Picked tile:\",\n      this.worldTileForSceneCoordinate(sceneX, sceneY)\n    );\n\n    const tileCenterX =\n      sceneX - (sceneX % TILE_PIXEL_LENGTH) + TILE_PIXEL_LENGTH / 2;\n    const tileCenterY =\n      sceneY - (sceneY % TILE_PIXEL_LENGTH) + TILE_PIXEL_LENGTH / 2;\n\n    const to = {\n      x: tileCenterX - this.width() / 2,\n      y: tileCenterY - this.height() / 2\n    };\n\n    this.tweenCameraToSceneCoordinate(to);\n  };\n\n  stopCurrentCameraTween() {\n    if (this._cameraTween) {\n      // noinspection JSUnresolvedFunction\n      this._cameraTween.stop();\n      this._cameraTween = null;\n    }\n  }\n\n  /**\n   *\n   * @param to {{x: number, y: number}}\n   */\n  tweenCameraToSceneCoordinate(to) {\n    this._cameraDelta.x = 0;\n    this._cameraDelta.y = 0;\n\n    this.stopCurrentCameraTween();\n\n    const coords = {\n      x: this._camera.position.x,\n      y: this._camera.position.y\n    };\n\n    const last = { ...coords };\n\n    this._cameraTween = new TWEEN.Tween(coords)\n      .to(to, 1000)\n      .easing(TWEEN.Easing.Quadratic.Out)\n      .onUpdate(() => {\n        this._cameraDelta.x += coords.x - last.x;\n        this._cameraDelta.y += coords.y - last.y;\n        last.x = coords.x;\n        last.y = coords.y;\n      })\n      .start();\n  }\n\n  /**\n   * Register all event listeners\n   */\n  listenForMouseEvents() {\n    this._canvas.addEventListener(\"mousemove\", this._mouseMoveHandler);\n    this._canvas.addEventListener(\"mousedown\", this._mouseDownHandler);\n    this._canvas.addEventListener(\"mouseup\", this._mouseUpHandler);\n    this._canvas.addEventListener(\"click\", this._clickHandler);\n    this._canvas.addEventListener(\"dblclick\", this._doubleClickHandler);\n  }\n\n  /**\n   * De-register all mouse event listeners\n   */\n  stopListeningForMouseEvents() {\n    this._canvas.removeEventListener(\"mousemove\", this._mouseMoveHandler);\n    this._canvas.removeEventListener(\"mousedown\", this._mouseDownHandler);\n    this._canvas.removeEventListener(\"mouseup\", this._mouseUpHandler);\n    this._canvas.removeEventListener(\"dblclick\", this._doubleClickHandler);\n  }\n\n  /**\n   * Theoretically you could have multiple of these objects so give them a semi-\n   * unique name.\n   *\n   * @return {string}\n   */\n  name() {\n    return \"renderer-\" + this._index;\n  }\n\n  generateTestMap() {\n    const map = this._map;\n    const size = map.length;\n    for (let i = size; i >= 0; i--) {\n      const x = i % MAP_TILES_WIDE;\n      const y = Math.floor(i / MAP_TILES_WIDE);\n      const chunkY = y % CHUNK_TILE_LENGTH;\n      const chunkX = x % CHUNK_TILE_LENGTH;\n\n      if (chunkY === 0 || chunkY === CHUNK_TILE_LENGTH - 1) {\n        map[i] = 0;\n      } else if (chunkX === 0 || chunkX === CHUNK_TILE_LENGTH - 1) {\n        map[i] = 4;\n      } else {\n        map[i] = 8;\n      }\n    }\n  }\n\n  generateMap() {\n    const map = this._map;\n    const size = map.length;\n    const materialCount = this._tileMaterials.size();\n    for (let i = size; i >= 0; i--) {\n      map[i] = Math.floor(Math.random() * materialCount);\n    }\n  }\n\n  /**\n   * Resizes the scene. A very computationally intensive procedure so it must be\n   * debounced.\n   *\n   * @param windowWidth {number}\n   * @param windowHeight {number}\n   */\n  resize = (windowWidth, windowHeight) => {\n    this._renderer.setSize(windowWidth, windowHeight);\n    this._camera.left = 0;\n    this._camera.right = windowWidth;\n    this._camera.top = windowHeight;\n    this._camera.bottom = 0;\n    this._camera.near = -1;\n    this._camera.far = 2000;\n\n    // Three requires us to call this whenever the cameras shape is updated.\n    this._camera.updateProjectionMatrix();\n\n    // Resize the chunks themselves.\n    this._chunkRenderer.resize(windowWidth, windowHeight, this._scene);\n    this._objects.offsetForChunkRenderer(this._chunkRenderer);\n\n    const { width, height } = this._chunkRenderer.sceneDimensions();\n\n    this._lighting.resize(width, height);\n\n    // How far the camera can move from the center of the scene before chunks\n    // have to be shimmied around\n    this._panBoundary.offset = CHUNK_PIXEL_LENGTH;\n    this._panBoundary.top = height - windowHeight;\n    this._panBoundary.bottom = 0;\n    this._panBoundary.left = 0;\n    this._panBoundary.right = width - windowWidth;\n\n    // Resize the boundary away from which you're allowed to pan off the maps\n    // edges.\n    const boundary = this._distanceAllowedToPanOffMap;\n    this._offMapBoundary.left = -boundary;\n    this._offMapBoundary.right = width - (windowWidth - boundary);\n    this._offMapBoundary.top = height - (windowHeight - boundary);\n    this._offMapBoundary.bottom = -boundary;\n  };\n\n  /**\n   * The width of the rendered area in pixels.\n   * @return {number}\n   */\n  width() {\n    return this._camera.right;\n  }\n\n  /**\n   * The height of the rendered area in pixels.\n   * @return {number}\n   */\n  height() {\n    return this._camera.top;\n  }\n\n  /**\n   * Stop rendering and clean up all listeners and GL assets.\n   */\n  destroy() {\n    this._rendering = false;\n\n    stopListeningForResize(this.name());\n    stopListeningForKeydown(this.name());\n    this.stopListeningForMouseEvents();\n    this._chunkRenderer.dispose();\n    this._tileMaterials.dispose();\n    this._objects.dispose();\n    this._objectMaterials.dispose();\n    this._renderer.dispose();\n\n    this._map = null;\n    this._chunkRenderer = null;\n    this._scene = null;\n    this._renderer = null;\n  }\n\n  /**\n   * DOM keydown event handler\n   * @param key {string} The key pressed.\n   */\n  keydown = key => {\n    let cy = 0;\n    let cx = 0;\n\n    switch (key) {\n      case \"8\":\n      case \"w\":\n        cy += Renderer.KEY_JUMP_SIZE;\n        break;\n      case \"2\":\n      case \"s\":\n        cy -= Renderer.KEY_JUMP_SIZE;\n        break;\n      case \"4\":\n      case \"a\":\n        cx -= Renderer.KEY_JUMP_SIZE;\n        break;\n      case \"6\":\n      case \"d\":\n        cx += Renderer.KEY_JUMP_SIZE;\n        break;\n      case \"7\":\n        cy += Renderer.KEY_JUMP_SIZE;\n        cx -= Renderer.KEY_JUMP_SIZE;\n        break;\n      case \"9\":\n        cy += Renderer.KEY_JUMP_SIZE;\n        cx += Renderer.KEY_JUMP_SIZE;\n        break;\n      case \"1\":\n        cy -= Renderer.KEY_JUMP_SIZE;\n        cx -= Renderer.KEY_JUMP_SIZE;\n        break;\n      case \"3\":\n        cy -= Renderer.KEY_JUMP_SIZE;\n        cx += Renderer.KEY_JUMP_SIZE;\n        break;\n      case \"l\":\n        this._showLighting = !this._showLighting;\n        if (this._showLighting) {\n          this._scene.add(this._lighting.sceneObject());\n        } else {\n          this._scene.remove(this._lighting.sceneObject());\n        }\n        break;\n      case \"+\":\n        this._lighting.offsetAmbientLightIntensity(.05);\n        break;\n      case \"-\":\n        this._lighting.offsetAmbientLightIntensity(-0.05);\n        break;\n      case \" \":\n        this.toggleRendering();\n        break;\n      default:\n        console.debug(\"Unhandled key\", key);\n        break;\n    }\n\n    if (cx || cy) {\n      this.stopCurrentCameraTween();\n      this._cameraDelta.x += cx;\n      this._cameraDelta.y += cy;\n    }\n  };\n\n  /**\n   * Center the camera on a world map tile (x, y)\n   *\n   * @param x {number}\n   * @param y {number}\n   */\n  centerCameraOnTile(x, y) {\n    console.assert(x >= 0);\n    console.assert(y >= 0);\n    console.assert(x < MAP_TILES_WIDE);\n    console.assert(y < MAP_TILES_HIGH);\n\n    // What chunk in the map is (x,y) in?\n    const chunkX = Math.floor(x / CHUNK_TILE_LENGTH);\n    const chunkY = Math.floor(y / CHUNK_TILE_LENGTH);\n\n    const sceneChunksWide = this._chunkRenderer.chunksWide();\n    const sceneChunksHigh = this._chunkRenderer.chunksHigh();\n\n    // Find the (left, top) chunk such that the pixel we're trying to center on\n    // is in the middle of the scene.\n    const left = Math.min(\n      Math.max(0, chunkX - Math.floor(sceneChunksWide / 2)),\n      MAP_CHUNKS_WIDE\n    );\n\n    const top = Math.min(\n      Math.max(0, chunkY - Math.floor(sceneChunksHigh / 2)),\n      MAP_TILES_HIGH\n    );\n\n    this._chunkRenderer.setLeftTop(left, top);\n    this._objects.offsetForChunkRenderer(this._chunkRenderer);\n\n    // This function is a camera movement\n    this._cameraDelta.x = 0;\n    this._cameraDelta.y = 0;\n\n    // Set the world tile that the camera is looking at\n    this._cameraWorldTile.x = x;\n    this._cameraWorldTile.y = y;\n\n    // Place the camera\n    const { sceneX, sceneY } = this.sceneCoordinateForWorldTile(x, y);\n    this._camera.position.x = sceneX - Math.round(this.width() / 2);\n    this._camera.position.y = sceneY - Math.round(this.height() / 2);\n  }\n\n  /**\n   * Return scene (x,y) pixel coordinates for a world tile coordinate\n   *\n   * @param x {number}\n   * @param y {number}\n   * @return {{sceneY: number, sceneX: number}}\n   */\n  sceneCoordinateForWorldTile(x, y) {\n    const left = this._chunkRenderer.left();\n    const top = this._chunkRenderer.top();\n    const worldPixelX = x * TILE_PIXEL_LENGTH;\n    const worldPixelY = y * TILE_PIXEL_LENGTH;\n    const sceneX = worldPixelX - left * CHUNK_PIXEL_LENGTH;\n    const sceneY = worldPixelY - top * CHUNK_PIXEL_LENGTH;\n    return { sceneX, sceneY };\n  }\n\n  /**\n   * Return a world tile coordinate (as a float) for a scene pixel coordinate.\n   *\n   * @param sceneX {number}\n   * @param sceneY {number}\n   * @return {{x: number, y: number}}\n   */\n  worldTileForSceneCoordinate(sceneX, sceneY) {\n    const left = this._chunkRenderer.left() * CHUNK_PIXEL_LENGTH;\n    const top = this._chunkRenderer.top() * CHUNK_PIXEL_LENGTH;\n    const x = (sceneX + left) / TILE_PIXEL_LENGTH;\n    const invert = this._chunkRenderer.sceneDimensions().height - sceneY;\n    const y = (invert + top) / TILE_PIXEL_LENGTH;\n    return { x, y };\n  }\n\n  /**\n   * Toggle frame rendering.\n   */\n  toggleRendering() {\n    if (!this._rendering) {\n      this.startRendering();\n    } else {\n      this.stopRendering();\n    }\n  }\n\n  /**\n   * Start the renderer drawing frames.\n   */\n  startRendering() {\n    if (this._rendering) {\n      console.warn(\"Attempt to start rendering while already started.\");\n      return;\n    }\n\n    console.log(\"Rendering started.\");\n    this._rendering = true;\n    this._renderer.setAnimationLoop(this.render);\n  }\n\n  /**\n   * Stop the renderer from drawing frames. (It'll actually de-register itself\n   * the next time getAnimationFrame() is called.)\n   */\n  stopRendering() {\n    if (!this._rendering) {\n      console.warn(\"Attempt to stop rendering twice.\");\n      return;\n    }\n\n    this._rendering = false;\n  }\n\n  /**\n   * Start the engine! Registers window event listeners and begins rendering.\n   */\n  start() {\n    listenForResize(this.name(), this.resize);\n    listenForKeydown(this.name(), this.keydown);\n    this.listenForMouseEvents();\n\n    const midX = Math.floor(MAP_TILES_WIDE / 2);\n    const midY = Math.floor(MAP_TILES_HIGH / 2);\n    this.centerCameraOnTile(midX, midY);\n    this.startRendering();\n  }\n\n  /**\n   * Apply whatever delta X, Y has been queued up for the camera since the last\n   * time a frame was rendered. This will check to make sure we dont pan too far\n   * away from the map and further ensure that we pan the scene's map chunks to\n   * maintain the illusion that the scene itself stretches on forever.\n   *\n   * @private\n   */\n  _applyCameraDelta() {\n    const dX = this._cameraDelta.x;\n    const dY = this._cameraDelta.y;\n\n    // The easy out case\n    if (!dX && !dY) {\n      return;\n    }\n\n    let { x, y } = this._camera.position;\n    x += dX;\n    y += dY;\n\n    // If this is true then we need to reorient chunks\n    let delta = false;\n\n    // If we've panned higher than the scene pan boundary\n    if (y > this._panBoundary.top) {\n      // Try to pan up in the world\n      if (this._chunkRenderer.panUp()) {\n        // If we panned up (i.e.: there was more map), adjust the camera down by\n        // the offset to make it seem like we're panning smoothly. This is the\n        // core pantomime that achieves the effect of \"infinite\" maps.\n        y -= this._panBoundary.offset;\n        // Mark the fact that we're going to need to reorient\n        delta = true;\n      } else if (y > this._offMapBoundary.top) {\n        // If we get here, it means that we're off the map, so make sure we dont\n        // scroll past a comfortable boundary.\n        y = this._offMapBoundary.top;\n      }\n    } else if (y < this._panBoundary.bottom) {\n      // Same tests as above, but for panning down.\n      if (this._chunkRenderer.panDown()) {\n        y += this._panBoundary.offset;\n        delta = true;\n      } else if (y < this._offMapBoundary.bottom) {\n        y = this._offMapBoundary.bottom;\n      }\n    }\n\n    // Same tests as above but for left and right\n    if (x > this._panBoundary.right) {\n      if (this._chunkRenderer.panRight()) {\n        x -= this._panBoundary.offset;\n        delta = true;\n      } else if (x > this._offMapBoundary.right) {\n        x = this._offMapBoundary.right;\n      }\n    } else if (x < this._panBoundary.left) {\n      if (this._chunkRenderer.panLeft()) {\n        x += this._panBoundary.offset;\n        delta = true;\n      } else if (x < this._offMapBoundary.left) {\n        x = this._offMapBoundary.left;\n      }\n    }\n\n    // Reset deltas now that they've been applied\n    this._cameraDelta.x = 0;\n    this._cameraDelta.y = 0;\n\n    // Keep track of where in the world the camera is pointing.\n    this._cameraWorldTile.x += dX / TILE_PIXEL_LENGTH;\n    this._cameraWorldTile.y += dY / TILE_PIXEL_LENGTH;\n\n    // Apply the new camera positions\n    this._camera.position.x = x;\n    this._camera.position.y = y;\n\n    // If we happened to have successfully panned, reorient the map chunks.\n    if (delta) {\n      this._chunkRenderer.reorientChunks();\n      this._objects.offsetForChunkRenderer(this._chunkRenderer);\n    }\n  }\n\n  /**\n   * Basically the boilerplate to set up the scene and call render() on the\n   * Three.JS renderer. This function shouldn't be called directly and should\n   * instead be passed to WebGLRenderer#setAntimationLoop\n   *\n   * @param time {number} The current frame time\n   */\n  render = time => {\n    if (!this._rendering) {\n      this._renderer.setAnimationLoop(null);\n      console.log(\"Rendering stopped.\");\n    }\n\n    stats.begin();\n\n    // noinspection JSUnresolvedFunction\n    TWEEN.update(time);\n\n    this._applyCameraDelta();\n    this._lighting.render(this._renderer);\n    this._chunkRenderer.update(this._renderer);\n\n    this._renderer.setRenderTarget(null);\n    this._renderer.render(this._scene, this._camera);\n\n    stats.end();\n  };\n}\n","import Renderer from \"./renderer\";\n\n/**\n *\n * @type {null|Renderer}\n * @private\n */\nlet _renderer = null;\n\nexport function destroy() {\n  if (_renderer) {\n    _renderer.destroy();\n  }\n}\n\n/**\n *\n * @param canvas {HTMLElement}\n */\nexport function attach(canvas) {\n  if (_renderer) {\n    console.warn(\"Overriding renderer.\");\n  }\n\n  _renderer = new Renderer(canvas);\n  _renderer.generateMap();\n  _renderer.start();\n}\n","import React from \"react\";\n\nimport { attach, destroy } from \"../../gl/main\";\nimport styled from \"styled-components\";\n\nclass Display extends React.Component {\n  constructor(props) {\n    super(props);\n    this.ref = React.createRef();\n  }\n\n  componentDidMount() {\n    attach(this.ref.current);\n  }\n\n  componentWillUnmount() {\n    console.warn(\"Unmounting <Display />! This may indicate a problem.\");\n    destroy();\n  }\n\n  render() {\n    return (\n      <canvas id={\"game\"} className={this.props.className} ref={this.ref} />\n    );\n  }\n}\n\nexport default styled(Display)`\n  display: block;\n`;\n","import React, { Component } from \"react\";\nimport Display from \"./components/Display\";\nimport { canRun, warn } from \"./util/compatability\";\nimport * as stats from \"./util/stats-wrapper\";\n\nfunction ErrorDisplay() {\n  return (\n    <div>\n      <p>Couldn't initialize renderer. Check the console.</p>\n    </div>\n  );\n}\n\nclass App extends Component {\n  static RUN = canRun();\n\n  componentDidMount() {\n    if (!App.RUN) {\n      return;\n    }\n\n    stats.show();\n    warn();\n  }\n\n  render() {\n    return (\n      <div className=\"App\">{App.RUN ? <Display /> : <ErrorDisplay />}</div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}